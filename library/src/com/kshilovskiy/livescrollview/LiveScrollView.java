package com.kshilovskiy.livescrollview;
import android.content.Context;
import android.content.res.TypedArray;
import android.database.DataSetObserver;
import android.util.AttributeSet;
import android.view.View;
import android.view.ViewGroup;
import android.view.ViewTreeObserver;
import android.widget.BaseAdapter;
import android.widget.LinearLayout;
import android.widget.ScrollView;

import java.util.ArrayList;
import java.util.List;

/**
 * Created with IntelliJ IDEA.
 * User: konstantinshilovskiy
 * Date: 12/3/12
 *
 * The class acts as a decorator for NonScrollableListView in order to add new visual effect
 */
public class LiveScrollView extends ScrollView{
    private BaseAdapter mAdapter;
    private AdapterDataSetObserver mDataSetObserver;
    private NonScrollableListView mListView;

    //View properties which user can specify
    private int mResizableViewId;
    private float mMinElementHeight;
    private float mMaxElementHeight;
    private float mFirstResizablePaddingTop;

    private int mChildCount = 0;
    private List<View> mParentViews;
    private List<View> mResizableViews;


    public LiveScrollView(Context context) {
        super(context);

        setupViews(context);
    }

    public LiveScrollView(Context context, AttributeSet attrs) {
        super(context, attrs);
        TypedArray a = context.getTheme().obtainStyledAttributes(
                attrs,
                R.styleable.LiveScrollView,
                0, 0);

        try {
            mMinElementHeight = a.getDimension(R.styleable.LiveScrollView_minResizableHeight, 0);
            mMaxElementHeight = a.getDimension(R.styleable.LiveScrollView_maxResizableHeight, 0);
            mFirstResizablePaddingTop = a.getDimension(R.styleable.LiveScrollView_firstResizablePaddingTop, Float.MIN_VALUE);
        } finally {
            a.recycle();
        }
        setupViews(context);
    }

    public LiveScrollView(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
        setupViews(context);
    }

    /**
     * Registers local observer once the view is attached  to a window
     */
    @Override
    protected void onAttachedToWindow() {
        super.onAttachedToWindow();
        if (mAdapter != null && mDataSetObserver != null) {
            mDataSetObserver = new AdapterDataSetObserver();
            mAdapter.registerDataSetObserver(mDataSetObserver);
        }
    }

    /**
     * Removes local observer once the view is detached  from a window
     */
    @Override
    protected void onDetachedFromWindow() {
        super.onDetachedFromWindow();
        if (mAdapter != null && mDataSetObserver != null) {
            mAdapter.unregisterDataSetObserver(mDataSetObserver);
        }
    }

    /**
     * Propagates the adapter to the NonScrollableListView and registers local DataSetObserver
     * @param adapter
     */
    public void setAdapter(BaseAdapter adapter){
        mListView.setAdapter(adapter);

        mAdapter = adapter;

        if(mAdapter != null && mDataSetObserver != null){
            adapter.unregisterDataSetObserver(mDataSetObserver);
        }

        mDataSetObserver = new AdapterDataSetObserver();
        mAdapter.registerDataSetObserver(mDataSetObserver);

        mDataSetObserver.onChanged();
    }

    /**
     * Ovverides super class metod and resizes children
     * @param l
     * @param t
     * @param oldl
     * @param oldt
     */
    @Override
    protected void onScrollChanged(int l, int t, int oldl, int oldt) {
        super.onScrollChanged(l, t, oldl, oldt);

        resizeChildren();

    }

    /**
     * Calculates the difference between top property of the root view(the one generated by mAdapter's getView() method)
     * and current scrollY() value. Then subtract it from the current resizable view height.
     * Also apllys limits(mMinElementHeight and mMaxElementHeight) if the calculated value pushes them
     */
    private void resizeChildren(){
        for(int i = 0; i < mChildCount; i++){
            View parentView = mParentViews.get(i);
            View resizableView = mResizableViews.get(i);

            int scrollY = getScrollY();
            int top = parentView.getTop() + parentView.getPaddingTop() - (int)mFirstResizablePaddingTop;

            LinearLayout.LayoutParams params = (LinearLayout.LayoutParams)resizableView.getLayoutParams();
            float height = Math.min(mMaxElementHeight,Math.max(mMinElementHeight, mMaxElementHeight + (top - scrollY)));


            params.height = (int)height;

            resizableView.setLayoutParams(params);
        }

        requestLayout();
    }

    /**
     * Registers global layout observer in order to measure child property when layout is finished
     * @param context
     */
    private void setupViews(Context context){
        mListView = new NonScrollableListView(context);

        mListView.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
            @Override
            public void onGlobalLayout() {
                mListView.getViewTreeObserver().removeGlobalOnLayoutListener(this);
                generateViewLists();
                resizeChildren();
            }
        });

        addView(mListView, new LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT));
    }

    /**
     * Generates list of views to be resized and their roote views. Also initializes total number of resizable views
     */
    private void generateViewLists(){
        int totalChildCount = mListView.getChildCount();

        mParentViews = new ArrayList<View>();
        mResizableViews = new ArrayList<View>();

        mChildCount = 0;
        for(int i = 0; i < totalChildCount; i++){


            View rootParentView = mListView.getChildAt(i);
            View resizebleView = rootParentView.findViewById(mResizableViewId);

            if(resizebleView != null){
                mParentViews.add(rootParentView);
                mResizableViews.add(resizebleView);

                mChildCount++;
            }

        }
    }

    /**
     * Specifies id of the view within root item view which should be resized
     * @param resizableViewId
     */
    public void setResizableViewId(int resizableViewId) {
        this.mResizableViewId = resizableViewId;
    }

    /**
     * Specifies minimu height of the resizable list view
     * @param minElementHeight
     */
    public void setMinElementHeight(float minElementHeight) {
        this.mMinElementHeight = minElementHeight;
    }

    /**
     * Specifies maximum height of the resizable list view
     * @param maxElementHeight
     */
    public void setMaxElementHeight(float maxElementHeight) {
        this.mMaxElementHeight = maxElementHeight;
    }

    /**
     * Specifies top offset after passing which the view should resize
     * @param firstResizablePaddingTop
     */
    public void setmFirstResizablePaddingTop(float firstResizablePaddingTop) {
        this.mFirstResizablePaddingTop = firstResizablePaddingTop;
    }

    /**
     * Propagates onClickListener to the NonScrollableListView
     * @param listener
     */
    public void setOnItemClickListener(OnItemClickListener listener){
        mListView.setOnItemClickListener(listener);
    }

    /**
     * Helper class which updated the list of the resizable and parent views once data set changes
     */
    private class AdapterDataSetObserver extends DataSetObserver {
        @Override
        public void onChanged() {
            generateViewLists();
        }
    }
}
